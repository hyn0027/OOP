下列程序是否存在编译错误或潜在风险？
若没有错误，请说明构造函数、复制构造函数、移动构造函数、赋值运算、移动赋值运算被调用的位置及次数。
若有编译错误或潜在风险，请指出所有错误和风险，说明理由。

(1):
没有错误
总计调用:
            构造函数Test()1次
            构造函数Test(int)1次
            拷贝构造函数1次
            移动构造函数3次
            拷贝复制运算0次
            移动赋值运算1次
            析构函数6次

Test F(Test a){ //(3+)调用一次拷贝构造函数
    Test b = std::move(a);//（4+）调用一次移动构造函数
    return b;   //(5+)调用一次移动构造函数
                //(4-)调用一次析构函数
}
int main(){
    Test a; //(1+)调用一次构造函数Test()
    a = 1;  //(2+)调用一次构造函数Test(int)
            //调用一次移动赋值函数
            //(2-)调用一次析构函数
    Test A = F(a);  //(6+)调用一次移动构造函数
                    //(5-)调用一次析构函数
                    //(3-)调用一次析构函数
    return 0;   //(6-)调用一次析构函数
                //(1-)调用一次析构函数
}

(2):
没有错误
总计调用：
            构造函数Test()0次
            构造函数Test(int)1次
            拷贝构造函数1次
            移动构造函数2次
            拷贝复制运算0次
            移动赋值运算0次
            析构函数4次

Test F(const Test& a){
    Test b = std::move(a);  //(2+)调用一次拷贝构造函数
    b.print("b");
    return b;   //(3+)调用一次移动构造函数
                //(2-)调用一次析构函数
}
int main(){
    Test A = F(1);  //(1+)调用一次构造函数Test(int)
                    //(4+)调用一次移动构造函数
                    //(3-)调用一次析构函数
                    //(1-)调用一次析构函数
    return 0;   //(4-)调用一次析构函数
}

(3):
没有错误
总计调用：
            构造函数Test()0次
            构造函数Test(int)1次
            拷贝构造函数1次
            移动构造函数2次
            拷贝复制运算0次
            移动赋值运算0次
            析构函数4次

Test F(Test &&a){
    cout << "???" << endl;
    Test b = std::move(a);  //(2+)调用一次移动构造函数
    b.print("b");
    return b;   //(3+)调用一次移动构造函数
                //(2-)调用一次析构函数
}
int main(){
    Test A = F(1);  //(1+)调用一次构造函数Test(int)
                    //(4+)调用一次移动构造函数
                    //(3-)调用一次析构函数
                    //(1-)调用一次析构函数
    A.print("A");
    return 0;   //(4-)调用一次析构函数
}

(4):
有编译错误&潜在风险：
    1. Test(1)是一个右值，调用F的时候，Test &a只能绑定左值，因而编译错误
    2. return std::move(b)处，返回了即将被析构的变量，将导致错误
Test&& F(Test &a){
    Test b = a;
    return std::move(b);
}
int main(){
    Test A = F(Test(1));
    return 0;
}

(5):
有编译错误&潜在风险：
    1. 返回的Test(1)将在离开F函数时被析构，将导致错误

const Test& F(const Test& a){
    Test b = a;
    return Test(1);
}
int main() {
    Test a;
    const Test &A = F(std::move(a));
    A.print("A");
    return 0;
}
